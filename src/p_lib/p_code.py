#! /usr/bin/python
# -*- coding: utf-8 -*-

__author__ = 'rh'
__date__ = "$18.07.2015 15:55:22$"

import os
import string
import ConfigParser  # read configfile
import hashlib

import p_glbls  # share global values
import p_utils
from   p_log import p_log_this
import p_cfg.patterns as patterns

# may be used in: def p_read_ini():
# pyprogen_ini = """
# [properties]
# prog_name = y_main
# """

def p_read_ini(dir_cfg='.', cfg_fn='pyprogen.ini'):
    """ reads defaults for generated program: name ..."""
    # http://www.karoltomala.com/blog/?p=622
    path = os.path.abspath(__file__)
    dir_path = os.path.dirname(path)
    print 'p_read_ini: dir_path = ', p_utils.p_act_dir_path()
    print 'p_read_ini: dir_path = ', dir_path
    print p_glbls.__file__
    p_log_this()
    cfg_path = os.path.join(dir_cfg, cfg_fn)
    cfg_path = os.path.normpath(cfg_path)
    parser = ConfigParser.SafeConfigParser(allow_no_value=True)
    # parser.readfp(io.BytesIO(pyprogen_ini))
    p_log_this('cfg_path: ' + cfg_path)
    cfg_file = parser.read(cfg_path)
    p_log_this('cfg file: ' + str(cfg_file))

    # p_glbls.prog_name
    try:
        p_glbls.prog_name = parser.get("properties", "prog_name")
        p_log_this('prog_name = ' + p_glbls.prog_name)
        if (len(p_glbls.prog_name) < 4):
            p_glbls.prog_name = p_glbls.prog_name + '.py'
            p_log_this('          =>' + p_glbls.prog_name)
        if ((string.lower(p_glbls.prog_name[-3:])) <> '.py'):
            p_glbls.prog_name = p_glbls.prog_name + '.py'
            p_log_this('          =>' + p_glbls.prog_name)
    except ConfigParser.NoOptionError:
        p_glbls.prog_name = 'z_main.py'
        p_log_this('no >prog_name< in: ' + cfg_path + ' !')
        p_log_this('prog_name set to: ' + p_glbls.prog_name)

    # p_glbls.prog_path
    p_glbls.prog_path = os.path.normpath(p_glbls.prog_name[:-3])
    print 'p_read_ini: p_glbls.prog_path = ', p_glbls.prog_path
    p_log_this("prog_path = " + p_glbls.prog_path)

    # p_glbls.prefix
    try:
        p_glbls.prefix = parser.get("properties", "prefix")
        p_log_this('prefix = ' + p_glbls.prefix)
        if (len(p_glbls.prefix) < 2):
            p_log_this('prefix = ' + p_glbls.prefix)
            p_glbls.prefix = p_glbls.prog_name[0] + '_'  # prefix for generated program
            p_log_this('prefix set to: ' + p_glbls.prefix)
    except ConfigParser.NoOptionError:
        p_glbls.prefix = p_glbls.prog_name[0] + '_'  # prefix for generated program
        p_log_this('prefix set to: ' + p_glbls.prefix)

    # p_glbls.my_code_fn
    try:
        p_glbls.my_code_fn = parser.get("properties", "my_code_fn")
        p_log_this('my_code_fn = ' + p_glbls.my_code_fn)
        if (len(p_glbls.my_code_fn) < 3):
            p_glbls.my_code_fn = p_glbls.my_code_fn + '.py'
            p_log_this('          =>' + p_glbls.my_code_fn)
        if ((string.lower(p_glbls.my_code_fn[-3:])) <> '.py'):
            p_glbls.my_code_fn = p_glbls.my_code_fn + '.py'
            p_log_this('          =>' + p_glbls.my_code_fn)
    except ConfigParser.NoOptionError:
        p_glbls.my_code_fn = 'my_code.py'
        p_log_this('no >my_code_fn< in: ' + cfg_path + ' !')
        p_log_this('my_code_fn set to: ' + p_glbls.my_code_fn)


def create_some_file_names():
    p_glbls.glbls_fn   = p_glbls.prefix + 'glbls.py'    # globals of >y_main.py< !
    p_glbls.my_code_fn = p_glbls.prefix + p_glbls.my_code_fn
    p_glbls.CAParser_func = p_glbls.prefix + 'parser'


def p_subst_vars_in_patterns (input_dict):
    """ substitutes in code parts (input_dict) some words (xx_....) with variable names """
    p_log_this()
    patts = dict()
    for key, patt in input_dict.iteritems():
        txt = patt.replace("xx_CAParser", p_glbls.CAParser_fn[:-3])
        txt =  txt.replace("xx_main",     p_glbls.prog_name[:-3])
        txt =  txt.replace("xx_parser",   p_glbls.CAParser_func)
        txt =  txt.replace("xx_glbls",    p_glbls.glbls_fn[:-3])
        txt =  txt.replace("xx_my_code",  p_glbls.my_code_fn[:-3])
        patts[key] = txt
    return patts


def p_write_code (input_dict, outfile_fn, outfile_path):
    """ writes >input_dict< to outfile """
    p_log_this()
    now_str = p_utils.p_make_act_date_str()
    p_log_this('writing: ' + outfile_path)
    with open(outfile_path, 'w') as outfile:
        outfile.write('# ' + now_str + ' generated by: >pyprogen.py<\n')
        #for key, patt in patts.iteritems():
        for key, patt in sorted(input_dict.iteritems()):
            outfile.write(patt)
        outfile.write('# ' + now_str)

def p_globals():
    """ creates ./y_main/lib/y_glbls.py  """
    p_log_this(' begin')

    txt =       ' '*4 + '# optional args(ConfArgParser):\n'
    for arg in p_glbls.opt_arg_vars:
        txt = txt + ' '*4 + 'arg_ns.' + arg + ' = None\n'
    txt = txt + ' '*4 + '# positional args(ConfArgParser):\n'
    for arg in p_glbls.pos_arg_vars:
        txt = txt + ' '*4 + 'arg_ns.' + arg + ' = None\n'
    txt = txt + ' '*4 + 'return arg_ns\n'
    patterns.y_glbls[04] = txt

    txt = ''
    patterns.y_glbls[96] = txt

    # fn and path of  >y_glbls.py<
    outfile_fn   = p_glbls.glbls_fn
    outfile_path = os.path.join(p_glbls.dir_lib, p_glbls.glbls_fn)

    # p_subst(patterns.y_glbls, outfile_fn, outfile_path)
    code = p_subst_vars_in_patterns (patterns.y_glbls)
    p_write_code (code, outfile_fn, outfile_path)
    p_log_this(' end' )


def check_my_code_modified(outfile_path):
    my_code_file = p_utils.p_file_open(outfile_path, mode = 'r')
    # if my_code_file:
    #     print outfile_path + ' opened.'
    # else:
    #     print outfile_path + ' does not exist!'

    code_to_hash = ''
    with my_code_file:
        code_to_hash = my_code_file.readlines()

    code_to_hash = str(code_to_hash).splitlines(3)

    # code = myfile.read().replace('\n', '')
    # line_first = my_code_file.readline()
    # line_hash  = my_code_file.readline()
    # print line_hash
    # code_to_hash   = my_code_file.readlines()
    hash_md5       = hashlib.md5()
    code_to_hash   = str (code_to_hash)
    hash_md5.update(code_to_hash)
    hash_of_code   = hash_md5.hexdigest()
    print hash_of_code
    p_utils.p_file_close(my_code_file)
    return code_to_hash

def p_my_code():
    """ creates y_my_code.py """

    p_log_this(' begin')
    # fn and path of  >y_main.py<
    outfile_fn = p_glbls.my_code_fn
    outfile_path = os.path.join(p_glbls.dir_lib, outfile_fn)
    # write code_to_hash of  >y_my_code.py<

    txt =       ' '*4 + '# optional args(ConfArgParser):\n'
    for arg in p_glbls.opt_arg_vars:
        txt = txt + ' '*4 + 'if ' + 'y_glbls.arg_ns.' + arg + ' == "something":\n'
        txt = txt + ' '*8 + 'eval_arg(y_glbls.arg_ns.' + arg +')\n'
        txt = txt + '\n'

    patterns.y_my_code[10] = txt

    y_my_code = p_subst_vars_in_patterns (patterns.y_my_code)

    code_to_hash = ''
    for key, chunk in sorted(y_my_code.iteritems()):
        code_to_hash = code_to_hash + chunk

    print '=' *40
    print len(code_to_hash)
    print '=' *40

    hash_md5 = hashlib.md5()
    hash_md5.update(code_to_hash)
    hash_of_mytext = hash_md5.hexdigest()

    y_my_code[01] = '# >' + hash_of_mytext + '< \n'
    p_write_code (y_my_code, outfile_fn, outfile_path)

    code_of_file = check_my_code_modified(outfile_path)
    print '*' *40
    print len(code_of_file)
    # print '*' *40
    # for key, patt in sorted(y_my_code.iteritems()):
    #     print (patt)
    print '*' *40
    # print code_of_file
    # print '*' *40
    print code_of_file[2:40]
    print '*' *40
    print code_to_hash[2:40]
    print '*' *40

    import difflib
    diff = difflib.ndiff(code_to_hash, code_of_file)
    # print ''.join(list(diff))
    # print ''.join(list(diff))


    p_log_this(' end' )


def p_main():
    """ creates y_main.py """
    p_log_this(' begin')
    # fn and path of  >y_main.py<
    outfile_fn = p_glbls.prog_name
    outfile_path = os.path.join(p_glbls.dir_main, outfile_fn)
    # write code of  >y_main.py<
    code = p_subst_vars_in_patterns (patterns.y_main)
    p_write_code (code, outfile_fn, outfile_path)
    p_log_this(' end' )


if __name__ == "__main__":
    print p_glbls.my_name()
    p_utils.p_exit()
